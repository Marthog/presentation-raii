\documentclass[conference,twocolumn]{IEEEtran}


\usepackage{listings}


\title{Memory models}



\begin{document}
	
\maketitle

\section{Local variables}
The easiest form of automated memory management are local variables. Local variables can not outlive their scope and the memory is automatically reclaimed by the program. They can be returned from functions by copying their values but pointers to the variables become invalid. It is easy for compilers to save them on the call stack or hold them in registers, making local variables the fastest form of memory allocation, because deallocation takes places by decreasing the stack size at the end of each functions and the locality of reference avoids cache misses. It is not possible to increase the capacity of stack allocated memory once it is no longer on the top of the stack and a stack allocated variable can not outlive it's function call.

These limits make exclusive local variable impractical for any programming language.


\section{Manual memory management}
In some languages, most notably C, the programmer needs to manage the memory by explicitly calling \verb|free| whenever it is no longer needed. That means that every code path in a program needs to  \\
This leads to many problems:
\begin{itemize}
    \item memory leaks when memory is never released
    \item use-after-free when a reference to an already freed location is accessed
    \item double delete when memory is deallocated twice
    \item repeated code because the memory needs to be released on every code path. As usual copied code often leads to other problems, especially when it is changed later.
    \item unreadable code when many nested \emph{if}-statements are used to prevent repeated code.
    \item separation of allocation and release
    \item exceptions are impractical to implement because they skip the code necessary for releasing.
\end{itemize}

Detecting and debugging memory related errors is very hard. Leaks occur seldom and need to waste a lot of memory before causing problems. \emph{use-after-free} and \emph{double delete} lead to undefined behavior. It is possible that everything works as expected and just under rare circumstances cause crashes or security issues.


\section{RAII}
\emph{Resource acquisition is initialization}, abbreviated as RAII, uses object oriented programming for memory management. Pointers to the resources are wrapped in an object which manages the access to it. Typically these objects contain a \emph{constructor} for allocating the resource, \emph{destructor} for releasing it and a copy or move operation so that the object's content can be transferred to other instances of the same type.

\begin{description}
	\item[Constructor] \hfill \\ initializes an object and allocates the resource
	\item[Copy or move]  \hfill \\ moves the object's content without keeping the actual object alive. This allows data to be kept alive after the scope's end by returning it from a function or transferring it into a data structure.
	\item[Destructor]  \hfill \\ releases the memory.
\end{description}


\begin{lstlisting}[language=c++,frame=single]
class Array<T> {
public:
    // Constructor
    Array(int length)
    {
        // allocate memory
        // and initialize the data
        data = new T[length];
    }
    
    // copy and/or move skipped
    
    // Destructor
    ~Array()
    {
        // deletes the memory
        // and calls all destructors
        delete[] data;
    }

private:
    T* data;
};
\end{lstlisting}


Typically some or all of the operations are generated by the compiler, so that except for writing some basic data structures and wrappers around imported code from other languages it is not necessary to provide these for each class.
When an object is destroyed at first the code of the destructor is executed and afterwards member variables and then the base class if present are destroyed.
RAII is not just useful for memory but also for other types of resources like file handles, network sockets and mutex guards.


\subsection{Destruction order}

% info on https://msdn.microsoft.com/en-us/library/6t4fe76c.aspx

An object is destroyed at the end of it's lifetime, which can be automatically done for temporary objects and local ones when they leave the scope, in many languages visible as the closing brace \verb|}|.

Member variables are destroyed by their parents destructor from the last to the first and afterwards the base classes' constructor is called if existent.

In all the automatic destructor calls the variables are destructed in reverse of their creation order and independent from the code path. RAII's destruction order is deterministic.

There are additional ways of creating and destroying objects manually, which is needed for implementing some basic types that itself use RAII but need to manage their internal memory manually. For example the C++ type \verb|vector| allocates more memory than it needs and constructs the objects internally. When elements are removed or the \verb|vector| is destroyed, then all of the elements destructors are called before the object itself gets destroyed. You rarely have to do the management yourself unless you need some specialized and efficient datastructures that are not part of the standard.










When an exception is thrown the runtime performs a \\ \emph{stack rewind} by going back all function calls and destroying every object until the according catch-statement has been reached. Destructors should not throw exceptions because throwing in a stack rewind would lead to two simultaneous active exception which most languages can not handle and immediately abort.






\subsection{Problems}
RAII improves the code structure by reducing code duplication, solves double deletes memory leaks but it does not solve use-after-free and the data structures need strict hierarchies without cyclic references.

\subsection{smart pointer}
Smart pointers are like raw pointers but free the memory they are pointing to. This is useful to separate between the normal pointers that just refer to an object and the owning pointers that control can be moved without invalidating the memory they are referring, so all other pointers remain valid. There are typically three types of smart pointers.\\

\verb|unique_ptr| (C++), \verb|Box| (Rust) holds a reference and frees the memory on deletion. It can not be copied.
\\

\verb|shared_ptr| (C++), \verb|Rc| (Rust) lets multiple smart pointers refer to the same memory location. When the last one is destroyed it frees up the memory. \verb|shared_ptr| is implemented with reference counting. When creating a new object it allocates additional space for another integer and stores a counter there. When a \verb|shared_ptr| is copied it increases the counter and the destructor decreases it. When the counter drops to zero the inner object is destroyed. This smart pointer allows multiple references but the programmer need to be careful to not create a cyclic dependency because that prevents the counter from becoming zero and may leak the whole cycle. \\

\verb|weak_ptr| refers to an object managed by shared pointers but does not increase the reference counter. It can not be used directly but upgraded to a \verb|shared_ptr| although that fails if the object has already been destroyed. The weak pointer can be used to break cycles. Other objects can still be accessed but when the reference count reaches zero the circle will be collected. \\
Weak pointers are implemented by adding another counter to the one used by a \emph{shared pointer}. When the reference counter drops to zero the object is destroyed but the memory not released, so that the second counter still remains valid. Then the memory is released on destruction of the last \emph{weak pointer}.


\subsection{Containers}
\emph{Containers} are classes that allocate memory for holding multiple objects. On destruction they call the destructors of all the elements in them and free the memory. Whereas \emph{smart pointers} contain a single element and allow downcasting to a base class, containers just allow a single type. Some operations can remove, add or internally move elements, causing pointers to individual elements or \emph{iterators} to dangle.
Containers normally do not provide mechanisms for allowing shared ownership. If you need it then wrap the objects in a shared pointer.





Classical RAII can not solve the problem of dangling pointers. There is no general way to ensure that a raw pointer still points to a valid object without applying additional and slow checks at runtime.






\section{RAII in garbage collected languages}
A garbage collector is an easily usable protection against memory related issues but lacks support of other resources. Classes often have finalizers that can close leaked resources but many of them including file handles and network sockets need to be closed as soon as possible so that other programs can use them. Often the release order matters and it takes an unpredictable time span to the next collection cycle so it sometimes takes too long and may cause nearly undetectable errors.
Traditionally garbage collected languages use finally to run specific code for resource release at the end of the scope, although that requires the discipline to surround every resource usage with a finally block and as a consequence is rarely used.
Some languages like \emph{D} support a garbage collector for memory and RAII for other resources. Other languages were extended with special keywords that enable RAII-like behavior.

\vline

\emph{Python 2.5} introduced the methods \verb|__enter__| and \verb|__exit__| that can be used with the new keyword \verb|with| to support automatically closing objects:
\begin{lstlisting}[language=python]
with open("test.file") as f:
    content = f.read()
\end{lstlisting}

\vline

\emph{Java 8} introduced the similar \emph{try-with-resources}
\begin{lstlisting}[language=java]
try (BufferedReader br =
    new BufferedReader(
    new FileReader(path))) {
        content = br.readLine();
}
\end{lstlisting}
The used class needs to implement the interface \verb|AutoClosable|.


\pagebreak

\section{Rust}
%short introduction to rust
Rust is a new language that aims at memory safety, abstractions without overhead and multithreading.

\subsection{Ownership}
The concept of ownership is not new. For reasoning about code in languages with RAII you often think about ownership in C++ and even in garbage collected languages a similar concept may improve code quality. Most of the time there is single ownership like the smart pointer \verb|unique_ptr| that owns one object as well as arrays, linked lists, hashmaps and other type of containers that have single ownership over multiple objects. Just in rare cases there is shared ownership with \verb|shared_ptr|.
The new aspect of rust's ownership is the compiler's ability verify it in most cases.

\vline

Variables have ownership over the resources they access.
You can create an heap-allocated array with three elements with
\begin{lstlisting}
let a = vec![1, 2, 3];
\end{lstlisting}
The variable \verb|a| has ownership over the content of the array. When \verb|a| goes out of scope it automatically reclaims the memory by using RAII.
You can transfer ownership to another value.
\begin{lstlisting}
let b = a;
\end{lstlisting}
The array is moved to \verb|b|. Accessing it afterwards is a compiler error.

\begin{lstlisting}
a.push(4); // append 4
\end{lstlisting}
will not compile because the content of \verb|a| has been moved to \verb|b| and can no longer accessed.
When multiple control paths exist and a value has been moved in one, it is no longer accessible.





\subsection{Borrowing}
An object can be accessed without taking ownership by borrowing it. A reference is created but the compiler applies additional checks to ensure that a reference can never outlive the referred object.

\begin{lstlisting}
fn foo() -> &i32 {
    let a = 12;
    
    // return reference to local var
    return &a;
}
\end{lstlisting}
will not compile because the reference to the local variable \verb|a| goes out of scope at the end of \verb|foo| and invalidate the returned reference.
Moving or modifying an object is not allowed if a reference to it exists.
Additionally only one mutable reference at a time may exist but multiple immutable ones are allowed. This solves the problem of \emph{iterator invalidity}: One reference mutates a container while an iterator is accessing the elements, letting it either point to now invalid memory, skipping elements or visiting them twice.
Forbidding aliasing of mutable pointers also allows some optimizations.

\subsection{Lifetimes}
The compiler enforces and validates the borrowing rules with lifetimes. These are encoded in the type system and bound to the scope. References' lifetimes can not be longer then the owning variables' ones.
References are represented by a leading single quote: \verb|'lifetime|
There is a special lifetime \verb|'static| for items that life as long as the process.

\begin{lstlisting}
struct Foo {
    x: i32,
}

// the lifetime 'a is a generic parameter
// it returns a reference with the same 
// livetime as the input
fn first_x<'a>(
        first: &'a Foo,
        second: &Foo)
        -> &'a i32 {
    &first.x
}
\end{lstlisting}

Although the compiler generates and checks the lifetime for every object, except for some ambiguous cases they can be automatically generated based on the context.

\end{document}
